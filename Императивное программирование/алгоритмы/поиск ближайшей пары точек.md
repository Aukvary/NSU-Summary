```C
int cmp_x(const void* a, const void* b) {
	return ((vec2*)a)->x - ((vec2*)b)->x;
}

int cmp_y(const void* a, const void* b) {
	return ((vec2*)a)->y - ((vec2*)b)->y;
}

float closest_pair_rec(vec2* points_x, vec2* points_y, int n, vec2 result[2]) {
	//если точек <= 3, то мы просто проходимся по всем
    if (n <= 3) {
        float min_dist = MAX;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                float d = distance(points_x[i], points_x[j]);
                if (d < min_dist) {
                    min_dist = d;
                    result[0] = points_x[i];
                    result[1] = points_x[j];
                }
            }
        }
        return min_dist;
    }
    
    int mid = n / 2; //середина массива
    float mid_x = points_x[mid].x; //среднее значение по х
    
    //разделяем массив на 2 части
    vec2* left_x = points_x; //левая часть
    vec2* right_x = points_x + mid; //правая часть
    
    //создаём временные массивы
    vec2* left_y = calloc(mid, sizeof(vec2));  
    vec2* right_y = calloc(n - mid, sizeof(vec2));
    
    int left_idx = 0;
    int right_idx = 0;
    for (int i = 0; i < n; i++) {
	    //если элемент массива у меньше медианы массива х, то записываем его в левый массив
        if (points_y[i].x < mid_x || (points_y[i].x == mid_x && left_idx < mid)) {
            left_y[left_idx++] = points_y[i];
        } else {
            right_y[right_idx++] = points_y[i];
        }
    }
    
    //массив результатов
    vec2 left_result[2];
    vec2 right_result[2];
    //рекурсивно проходимся по левой и правой части
    float left_dist = closest_pair_rec(left_x, left_y, mid, left_result);
    float right_dist = closest_pair_rec(right_x, right_y, n - mid, right_result);
    
    float delta;
    //смотрим, где расстояние меньше 
    if (left_dist < right_dist) {
        delta = left_dist;
        result[0] = left_result[0];
        result[1] = left_result[1];
    } else {
        delta = right_dist;
        result[0] = right_result[0];
        result[1] = right_result[1];
    }
    
    vec2* strip = calloc(n, sizeof(vec2));
    int strip_size = 0;
    for (int i = 0; i < n; i++) {
        if (abs(points_y[i].x - mid_x) < delta) {
            strip[strip_size++] = points_y[i];
        }
    }
    
    for (int i = 0; i < strip_size; i++) {
        for (int j = i + 1; j < strip_size && j < i + 16; j++) {
            float d = distance(strip[i], strip[j]);
            if (d < delta) {
                delta = d;
                result[0] = strip[i];
                result[1] = strip[j];
            }
        }
    }
    
    free(left_y);
    free(right_y);
    free(strip);
    
    return delta;
}

float get_min_dist(vec2* points, int n, vec2 result[2]) {
    if (n < 2) {
        return 0;
    }
    
    vec2* points_x = calloc(n, sizeof(vec2));
    vec2* points_y = calloc(n, sizeof(vec2));
    
    for (int i = 0; i < n; i++) {
        points_x[i] = points[i];
        points_y[i] = points[i];
    }
    
    qsort(points_x, n, sizeof(vec2), cmp_x);
    qsort(points_y, n, sizeof(vec2), cmp_y);
    
    float min_d = closest_pair_rec(points_x, points_y, n, result);
    
    free(points_x);
    free(points_y);
    
    return min_d;
}
```

##### асимптотика
- скорость - O($N\log N$)
- память - O($N$)
***
#императивное-программирование #поиск #алгоритм