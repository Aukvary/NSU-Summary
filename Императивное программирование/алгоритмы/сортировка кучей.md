```C
void make_heap(int* nums, int n, int i) {
    while (1) {
        int bigger = i; //индекс большего элемента

        int left = 2 * i + 1; //левый потомок
        int right = 2 * i + 2; //правый потомок 

		//если потомок существует и он больше, то меняем индекс
        if (left < n && nums[left] > nums[bigger]) {
            bigger = left;
        }
		//если потомок существует и он больше, то меняем индекс
        if (right < n && nums[right] > nums[bigger]) {
            bigger = right;
        }
		
		//если текущий наибольший, то прерываем цикл
        if (bigger == i) break;
        
        //меняем текущий элемент и наибольший
        swap(nums + i, nums + bigger);
        i = bigger; //меняем индекс текущего элементы 
    }
}

void sort(int* nums, int n) {
	//формируем кучу, делаем так, чтобы в тройке родитель 2 потомка, родитель был наибольшим
	// n / 2 - 1 - это последний родитель, проходимся по всем элементам начиная с него
    for (int i = n / 2 - 1; i > -1; i--) {
        make_heap(nums, n, i);
    }

    for (int i = n - 1; i > 0; i--) {
        swap(&nums[0], &nums[i]); //меняем наибольшее значение(первое) с последним элементом
        make_heap(nums, i, 0); //заново формируем кучу
    }
}
```

##### асимптотика
- скорость - O($N\log N$)
- память - O(1)
***
#императивное-программирование #сортировка #алгоритм