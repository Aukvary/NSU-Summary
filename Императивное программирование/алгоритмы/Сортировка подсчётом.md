```C
void counting_sort(KeyValuePair* nums, int n) {
    int nums_count[SIZE] = { 0 }; //массив, который считает сколько раз встретилось число, где SIZE - 1 это максимальное число

    int* res = calloc(n, sizeof(int)); //массив для результата

    for (int i = 0; i < n; i++) {
        bytes[nums[i]] += 1; //считаем сколько раз встретилось число nums[i]
    }

    for (int i = 1; i < 256; i++) {
        bytes[i] += bytes[i - 1]; //считаем сколько чисел <= nums[i]
    }

    for (int i = n - 1;  i > -1; i--) {
	    //--nums_count[nums[i]] - индекс в отсортированном массиве, потому что количество элементов, которые <= nums[i], равно индекс +1
        res[--nums_count[nums[i]]] = nums[i];
    }
	//переносим всё в основной массив
    memcpy(nums, res, n * sizeof(KeyValuePair));
    free(res);
}
```

##### асимптотика
- скорость - O($N + K$)
- память - O($N + K$)
***
#императивное-программирование #сортировка #алгоритм