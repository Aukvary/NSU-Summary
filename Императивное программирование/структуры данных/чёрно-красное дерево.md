##### основные свойства
1. Цвет узла может быть либо красным, либо черным.
2. Цвет корневого узла всегда черный.
3. Все листовые узлы черные.
4. У каждого красного узла оба дочерних узла окрашены в черный цвет.
5. Каждый простой путь от данного узла до любого из его листовых содержит одинаковое количество чёрных узлов
##### случаи вставки
1. новый узел добавляется как корень
	- узел перекрашивается в чёрный, тк корневой узел обязан быть чёрным 
	- остальные свойства  не нарушаются 
2. родительский узел нового узла чёрный 
	- свойство красно-чёрного дерева не нарушаются
3. родитель и дядя красные 
	- родитель и дядя перекрашиваются в чёрный, а прародитель перекрашивается в красный
4. родитель красный, а дядя чёрный, при этом новый узел это правый потомок, а родитель это левый потомок 
	- нужно совершить левый(правый, если родитель это правый потомок) поворот 
5. родитель красный, дядя чёрный, новый узел левый потомок и родитель левый потомок
	- выполняется поворот вправо(влево, если родитель был правым потомком) вокруг прародительского узла
	- меняем цвет родителя на чёрный, а прародителя на красный 
##### случаи удаления 
1. дочерний элемент новый корень
	- нужно перекрасить его в чёрный
2. сиблинг красный
	- если наш узел левый потомок, то мы совершаем левый поворот вокруг сиблинга и наоборот
	- цвет родителя меняется на красный, а сиблинга на чёрный
3. родитель, сиблинг и его потомки чёрные 
	- нужно перекрасить сиблинга в красный, таким образом чёрная высота сиблинга уменьшится 
4. дочерние элементы нашего узла и сиблинг чёрные, а родитель красный 
	- нужно перекрасить сиблинга в красный, а родительский узел в чёрный 
5. наш узел левый потомок, сиблинг чёрный, левый потомок сиблинга красный, а правый чёрный
	- правый поворот вокруг сиблинга 
	- перекрасить сиблинга в красный, а его правого потомка в чёрный 
	- и наоборот
6. сиблинг чёрный, а его правый потомок красный, а наш узел левый потомок 
	- левый(правый, если наш узел правый потомок) поворот вокруг родителя 
	- перекрасить правого(левого, если наш узел правый потомок)
## сигнатура
```C
typedef enum { RED, BLACK } Color;

typedef struct node {
    int data;
    Color color;
    struct node *left, *right, *parent;
} node;

node* create_node(int data) {
    node* node = malloc(sizeof(node));
    node->data = data;
    node->color = RED; 
    node->left = node->right = node->parent = NULL;
    return node;
}

void left_rotate(node** root, node* x) {
    node* y = x->right;
    x->right = y->left;
    
    if (y->left != NULL)
        y->left->parent = x;
    
    y->parent = x->parent;
    
    if (x->parent == NULL)
        *root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;
    
    y->left = x;
    x->parent = y;
}

void left_rotate(node** root, node* x) {
    node* y = x->right;
    x->right = y->left;
    
    if (y->left != NULL)
        y->left->parent = x;
    
    y->parent = x->parent;
    
    if (x->parent == NULL)
        *root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;
    
    y->left = x;
    x->parent = y;
}
```
## вставка
```C
void push(node** root, node* n) {
    node* parent = NULL;
    node* current = *root;
    
    while (current != NULL) {
        parent = current;
        if (n->val < current->val)
            current = current->left;
        else if (n->val > current->val)
            current = current->right;
        else
            return; 
    }
    
    n->parent = parent;
    n->left = NULL;
    n->right = NULL;
    n->color = RED; 
    
    if (parent == NULL) {
        *root = n; 
    } else if (n->val < parent->val) {
        parent->left = n;
    } else {
        parent->right = n;
    }
    
    case1(n);
}

void case1(node* n) {
	if (n->parent == NULL) {
		n->color = BLACK;
	} else case2(n);
}

void case2(node* n) {
	if (n->parent->color == BLACK) {
		return;
	} else case3(т);
}

void case3(node* n) {
	node* u = uncle(n);
	node* g = grandparent(n);
	
	if ((u != NULL) && u->color == RED) {
		n->parent->color = BLACK;
		u->color = BLACK;
		g->color = RED;
		case1(g);
	} else case4(n);
}

void case4(node* n) {
	node* g = grand_parent(n);
	
	if ((n == n->parent->right) && (n->parent == g->left)) {
		left_rotate(n->parent);
		n = n->left;
	} else if ((n == n->parent->left) && (n->parent == g->right)) {
		right_rotate(n->parent);
		n = n->right;
	}
	
	case5(n);
}

void case5(node* n) {
	node* g = grand_parent(n);
	
	if ((n == n->parent->left) && (n->parent == g->left)) {
		rotare_right(g);
	} else if (((n == n->parent->right) && (n->parent == g->right))) {
		left_rotate(g);
	}
	
	n->parent-color = BLACK;
	g->color = RED;
}
```
## поиск
```C
node* search(node* root, int data) {
    node* current = root;
    
    while (current != NULL) {
        if (data == current->data)
            return current;
        else if (data < current->data)
            current = current->left;
        else
            current = current->right;
    }
    return NULL;
}
```
## удаление
```C
void pop(node* n) {
	node* child;
	
	if (if_leaf(n->right)) {
		child = n->left;
	} else {
		child = n->right;
	}
	
	replace_node(n, child);
	
	if (n->color == BLACK) {
		if (child->color == RED) {
			child->color = BLACK;
		} else {
			case1(child);
		}
	}
	
	free(n);
}

void case1(node* n) {
	if (n->parent != NULL) case2(n);
}

void case2(node* n) {
	node* s = sibling(n);
	
	if (s->color == RED) {
		if (n == n->parent->left)
			rotate_left(n->parent);
		else 
			rotate_right(n->parent);
			
		n->parent->color = RED;
		s->color = BLACK;
	}
	
	case3(n);
}

void case3(node* n) {
	node* s = sibling(n);
	
	if ((n->parent->color == BLACK) && (s->color == BLACK) &&
		(s->left->color == BLACK) && (s->right->color == BLACK)) {
			s->color = RED;
			case1(n->parent);	
	} else case4(n);
}

void case4(node* n) {
	node* s = sibling(n);
	
	if ((n->parent->color = RED) && (s-color == BLACK) &&
		(s->left == BLACK) && (s->right-color == BLACK)) {
			s->color = RED;
			n->parent->color = BLACK;
	} else case5(n);
}

void case5(node* n) {
	node* s = sibling(n);
	
	if (s->color != BLACK) case6(n);
	
	if ((n == n->parent->left) && (s->right->color == BLACK) &&
		(s->left->color == RED)) right_rotate(s);
	else if ((n == n->parent->right) && (s->right->color == RED) &&
			 (s->left->color == BLACK)) left_rotate(s);
			 
	s->color = RED;
	s->right->color = BLACK;
	
	case6(n);
}

void case6(node* n) {
	node* s = sibling(n);
	
	s->color = n->parent->color;
	n->parent->color = BLACK;
	
	if (n == n->parent->left) {
		s->right->color = BLACK;
		left_rotate(n->parent);
	} else {
		s->left->color = BLACK;
		right_rotate(n->parent);
	}
}
```
***
#императивное-программирование #структура-данных #дерево